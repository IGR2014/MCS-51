; Смещение в памяти - 0h
; Тут лежат векторы прерываний - фактически это адреса по
; которым контроллер перейдёт в случае возникновения прерывания.
; Но начальный адрес 0000H должен перекидывать на основную программу (MAIN)
; чтоб после перезагрузки контроллер снова начинал её выполнять.
org	0h
	; Прыжок к основной программе
	ajmp	START

; Таблица векторов прерываний выглядит так:
;
; Номер прерывания	Адрес в памяти	Описание
; 0					0003h			Внешнее прерывание (INT0).
; 1					000Bh			Прерывание переполнения таймера/счётчика 0 (T/C0).
; 2					0013h			Внешнее прерывание (INT1).
; 3					001Bh			Прерывание переполнения таймера/счётчика 1 (T/C1).
; 4					0023h			Прерывание последовательного порта (UART).
;

; По условию задания используются прерывания INT0 и UART, поэтому:

; INT0
org	3h
	; Переход к обработчику прерывания INT0
	ajmp	EXT_INT_0

; INT UART
org	23h
	; Переход к обработчику прерывания (UART)
	ajmp	UART_0


; Смещение в памяти - 30h
; Тут начинается область кода основной программы.
org	30h

; Основная программа
START:
	; По-умолчанию все прерывания отключены т.к. для них не задано обработчиков.
	; Включаем те, для которых мы задали обработчики - INT0 и UART.
	; Для этого в регистре IE (Interrupt Enable) ставим 1 в нужных битах.

; Значения битов в регистре IE (Interrupt Enable):
;
; Номер бита	Обозначение	Описание
; 7				EA			Когда 0 - отключены все прерывания независимо от бит ниже. Когда 1 - включены те в которых ниже единица
; 6				-			Не используется. Зарезервировано на будущее.
; 5				-			Не используется. Зарезервировано на будущее.
; 4				ES			Включение/выключение прерывания от последовательного порта (UART).
; 3				ET1			Включение/выключение прерывания переполнения таймера/счётчика 1 (T/C1).
; 2				EX1			Включение/выключение внешнего прерывания (INT1).
; 1				ET0			Включение/выключение прерывания переполнения таймера/счётчика 0 (T/C0).
; 0				EX0			Включение/выключение внешнего прерывания (INT0). 

	; Теперь выставим значения в соответствии с таблицей выше:
	; Бит 0 - включено прерывание INT0.
	; Бит 4 - включено прерывание UART.
	mov		IE,		#00010001b
	; Теперь настройка приоритетов прерываний. В условии их придётся менять для тестов.
	; Меняются они в регистре IP (Interrupt Priority).
	; Приоритет может быть:
	; 0 - низкий
	; 1 - высокий

; Значения битов в регистре IP (Interrupt Priority):
;
; Номер бита	Обозначение	Описание
;
; 7				-			Не используется. Зарезервировано на будущее.
; 6				-			Не используется. Зарезервировано на будущее.
; 5				-			Не используется. Зарезервировано на будущее.
; 4				PS			Приоритет прерывания от последовательного порта (UART).
; 3				PT1			Приоритет прерывания переполнения таймера/счётчика 1 (T/C1).
; 2				PX1			Приоритет внешнего прерывания (INT1).
; 1				PT0			Приоритет прерывания переполнения таймера/счётчика 0 (T/C0).
; 0				PX0			Приоритет внешнего прерывания (INT0). 

	; На сейчас ставлю обоим прерываниям высокий приоритет:
	mov		IP,		#00010001b

	; Настройка регистра TCON (Timer Control Register). В условии ничего не сказано,
	; поэтому взял так-же из примера настройку:
	; Оба прерывания (INT0 и  UART) настроены на работу по срезу
	mov		TCON,	#01b

	; Счётчики числа перываний. В условии задачи не нашёл какие значения должны быть,
	; поэтому взял значение из примера - 6.
	; R0 - счётчик количества прерываний INT0
	; R1 - счётчик количества прерываний UART
	mov		R0,		#6
	mov		R1,		#6

	; Включаем прерывания (установка 1 в 7-м бите регистра IE)
	setb	EA

; Теперь начинается цикл формирования импульса. Расчёт взят из примера т.к. в задании не формулы для него
LOOP:
	; R2 - счётчик цикла. По формуле = t/2.
	; По заданию t = 130, поэтому в регистр R2 записываем 65
	mov		R2,		#65
	; Генерация сигнала на нулевом бите порта P1
	setb	P1.0
; Задержка на время t. Реализуется так:
PAUSE1:
	; Инструкция уменьшает значение в регистре R2 и если там не 0 - перепрыгивает сама на себя
	djnz	R2,		PAUSE1
	; Сброс сигнала на нулевом бите порта P1
	clr		P1.0
; Задержка на время T - t = 2 * R4 * R3. по заданию значение T = 750.
; Считаем: 750 - 130 = 620 = 2 * R4 * R3. Тогда:
; R4 * R3 = 750 / 2 = 375.
; Нужно выбрать значения R4 и R3 так чтоб получилось 375:
; Пусть будут значения 5 и 75 т.к. 5 * 75 = 375.
	; Предустановка значения R3 - выше мы выбрали 4
	mov		R3,		#5
; Итак, задержка на время T - t = 2 * R4 * R3.
PAUSE2:
	; Предустановка значения R4 - выше мы выбрали 72
	mov		R4,		#75
	; Инструкция уменьшает значение в регистре R4 и если там не 0 - перепрыгивает сама на себя
	djnz	R4,		$
	; Инструкция уменьшает значение в регистре R3 и если там не 0 - перепрыгивает на метку PAUSE2
	djnz	R3,		PAUSE2
	; Возврат в цикл формирования импульса
	ajmp	LOOP

; Обработчик прерывания INT0
EXT_INT_0:
	; Инструкция уменьшает значение в регистре R0 и если там не 0 - переходит сразу к выходу из обработки прерывания
	djnz	R0,		EXT_INT_0_EXIT
	; Запрет внешнего прерывания INT0 (иначе если во время обработки прилетит новое - контроллер перезагрузится).
	clr		EX0
; Сюда перепрыгнет, если в начале обработчика DJNZ получило в регистре R0 значение НЕ 0!
EXT_INT_0_EXIT:
	; Выход из обработчика прерывания INT0
	reti

; Обработчик прерывания UART
UART_0:
	; Инструкция уменьшает значение в регистре R1 и если там не 0 - переходит сразу к выходу из обработки прерывания
	djnz	R1,		UART_0_EXIT
	; Запрет прерывания последовательного порта UART (иначе если во время обработки прилетит новое - контроллер перезагрузится).
	clr		ES
; Сюда перепрыгнет, если в начале обработчика DJNZ получило в регистре R1 значение НЕ 0!
UART_0_EXIT:
	; Выход из обработчика прерывания UART
	reti

; Конец кода
end
