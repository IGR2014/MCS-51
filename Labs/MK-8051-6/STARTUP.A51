; Смещение в памяти - 0h
; Тут лежат векторы прерываний - фактически это адреса по
; которым контроллер перейдёт в случае возникновения прерывания.
; Но начальный адрес 0000H должен перекидывать на основную программу (MAIN)
; чтоб после перезагрузки контроллер снова начинал её выполнять.
org	0h
	; Прыжок к основной программе
	ajmp	START

; Таблица векторов прерываний выглядит так:
;
; Номер прерывания	Адрес в памяти	Описание
; 0					0003h			Внешнее прерывание (INT0).
; 1					000Bh			Прерывание переполнения таймера/счётчика 0 (T/C0).
; 2					0013h			Внешнее прерывание (INT1).
; 3					001Bh			Прерывание переполнения таймера/счётчика 1 (T/C1).
; 4					0023h			Прерывание последовательного порта.
;

; По условию задания используются прерывания INT0 и T/C0, поэтому:

; INT0
org	3h
	; Переход к обработчику прерывания INT0
	ajmp	INT_0

; INT1
org	0Bh
	; Переход к обработчику прерывания (T/C0)
	ajmp	TC_0


; Смещение в памяти - 30h
; Тут начинается область кода основной программы.
org	30h

; Основная программа
START:
	; По-умолчанию все прерывания отключены т.к. для них не задано обработчиков.
	; Включаем те, для которых мы задали обработчики - INT0 и T/C0.
	; Для этого в регистре IE (Interrupt Enable) ставим 1 в нужных битах.

; Значения битов в регистре IE (Interrupt Enable):
;
; Номер бита	Обозначение	Описание
; 7				EA			Когда 0 - отключены все прерывания независимо от бит ниже. Когда 1 - включены те в которых ниже единица
; 6				-			Не используется. Зарезервировано на будущее.
; 5				-			Не используется. Зарезервировано на будущее.
; 4				ES			Включение/выключение прерывания от последовательного порта.
; 3				ET1			Включение/выключение прерывания переполнения таймера/счётчика 1 (T/C1).
; 2				EX1			Включение/выключение внешнего прерывания (INT1).
; 1				ET0			Включение/выключение прерывания переполнения таймера/счётчика 0 (T/C0).
; 0				EX0			Включение/выключение внешнего прерывания (INT0). 

	; Теперь выставим значения в соответствии с таблицей выше:
	; Бит 0 - включено прерывание INT0.
	; Бит 2 - включено прерывание T/C0.
	mov		IE,		#00000011b
	; Теперь настройка приоритетов прерываний. В условии их придётся менять для тестов.
	; Меняются они в регистре IP (Interrupt Priority).
	; Приоритет может быть:
	; 0 - низкий
	; 1 - высокий

; Значения битов в регистре IP (Interrupt Priority):
;
; Номер бита	Обозначение	Описание
;
; 7				-			Не используется. Зарезервировано на будущее.
; 6				-			Не используется. Зарезервировано на будущее.
; 5				-			Не используется. Зарезервировано на будущее.
; 4				PS			Приоритет прерывания от последовательного порта.
; 3				PT1			Приоритет прерывания переполнения таймера/счётчика 1 (T/C1).
; 2				PX1			Приоритет внешнего прерывания (INT1).
; 1				PT0			Приоритет прерывания переполнения таймера/счётчика 0 (T/C0).
; 0				PX0			Приоритет внешнего прерывания (INT0). 

	; На сейчас ставлю обоим прерываниям высокий приоритет:
	mov		IP,		#00000011b

	; Настройка регистра TCON (Timer Control Register). В условии ничего не сказано,
	; поэтому взял так-же из примера настройку:
	; Оба прерывания (INT0 и T/C0) настроены на работу по срезу
	mov		TCON,	#01b

	; Счётчики числа перываний. В условии задачи не нашёл какие значения должны быть,
	; поэтому взял значение из примера - 6.
	; R0 - счётчик количества прерываний INT0
	; R1 - счётчик количества прерываний T/C0
	mov		R0,		#6
	mov		R1,		#6

	; Включаем прерывания (установка 1 в 7-м бите регистра IE)
	setb	EA

; Теперь начинается цикл формирования импульса. Расчёт взят из примера т.к. в задании не формулы для него
LOOP:
	; R2 - счётчик цикла. По формуле = t/2.
	; По заданию t = 70, поэтому в регистр R2 записываем 35
	mov		R2,		#35
	; Генерация сигнала на нулевом бите порта P1
	setb	P1.0
; Задержка на время t. Реализуется так:
PAUSE1:
	; Инструкция уменьшает значение в регистре R2 и если там не 0 - перепрыгивает сама на себя
	djnz	R2,		PAUSE1
	; Сброс сигнала на нулевом бите порта P1
	clr		P1.0
; Задержка на время T - t = 2 * R4 * R3. по заданию значение T = 650.
; Считаем: 650 - 70 = 580 = 2 * R4 * R3. Тогда:
; R4 * R3 = 580 / 2 = 290.
; Нужно выбрать значения R4 и R3 так чтоб получилось 290:
; Пусть будут значения 4 и 72 т.к. 4 * 72 = 288.
	; Предустановка значения R3 - выше мы выбрали 4
	mov		R3,		#4
; Итак, задержка на время T - t = 2 * R4 * R3.
PAUSE2:
	; Предустановка значения R4 - выше мы выбрали 72
	mov		R4,		#72
	; Инструкция уменьшает значение в регистре R4 и если там не 0 - перепрыгивает сама на себя
	djnz	R4,		$
	; Инструкция уменьшает значение в регистре R3 и если там не 0 - перепрыгивает на метку PAUSE2
	djnz	R3,		PAUSE2
	; Возврат в цикл формирования импульса
	ajmp	LOOP

; Обработчик прерывания INT0
INT_0:
	; Инструкция уменьшает значение в регистре R0 и если там не 0 - переходит сразу к выходу из обработки прерывания
	djnz	R0,		INT_0_EXIT
	; Запрет внешнего прерывания INT0 (иначе если во время обработки прилетит новое - контроллер перезагрузится).
	clr		ET0
; Сюда перепрыгнет, если в начале обработчика DJNZ получило в регистре R0 значение НЕ 0!
INT_0_EXIT:
	; Выход из обработчика прерывания INT0
	reti

; Обработчик прерывания T/C0
TC_0:
	; Инструкция уменьшает значение в регистре R1 и если там не 0 - переходит сразу к выходу из обработки прерывания
	djnz	R1,		TC_0_EXIT
	; Запрет внешнего прерывания T/C0 (иначе если во время обработки прилетит новое - контроллер перезагрузится).
	clr		ET1
; Сюда перепрыгнет, если в начале обработчика DJNZ получило в регистре R1 значение НЕ 0!
TC_0_EXIT:
	; Выход из обработчика прерывания T/C0
	reti

; Конец кода
end
